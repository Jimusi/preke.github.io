<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="Zhiyuan" type="application/atom+xml">






<meta name="description" content="三尺微命，一介书生">
<meta property="og:type" content="website">
<meta property="og:title" content="Zhiyuan">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Zhiyuan">
<meta property="og:description" content="三尺微命，一介书生">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zhiyuan">
<meta name="twitter:description" content="三尺微命，一介书生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>Zhiyuan</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zhiyuan</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">三尺微命，一介书生</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/18/随记1.18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Gold.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiyuan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/18/随记1.18/" itemprop="url">随记1.18</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-18T16:46:22+08:00">
                2017-01-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/随感/" itemprop="url" rel="index">
                    <span itemprop="name">随感</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="不忮不求">不忮不求</h2>
<p>诗经有：不忮不求，何用不臧 意思是不嫉妒不贪求，什么行为能不好呢</p>
<p>偶然看到这句话，然后百度了一下，看到一所中学的校训： <strong>有为有守，不忮不求</strong> 妙不可言，不禁感慨这所中学的文化底蕴，校训比太多太多的大学的校训要好太多了</p>
<p>君子，有作为，有操守，不嫉妒，不贪求 泰然自若，是内心对自己的一种肯定，是一种强大的自信</p>
<h2 id="议论文">议论文</h2>
<p>初中看过一篇励志演讲，说有个人中考作文满分，写的议论文就是请来一堆古今名家来一起讨论文章的主题；印象深刻的是，当时班里还有同学模仿这样的新奇模式，但是好像并没有收到良好的效果</p>
<p>个人觉得，议论文，就是议论为主，议论就是要多人参与 高中议论文，800字要求 一个观点，阐述清楚之后，还要多个事例佐证，难道是对自己的观点不自信么？ 苦思冥想找例证，旁征博引凑篇幅，好不牵强，好不啰嗦 我不认为提出自己的一个看法需要很长的篇幅，条理清晰，简明扼要，就够了 其他的方面是和他人的思想交流中再产生的，既然考场上不能交流，又怎能是议论文呢？ 自己议论吗？</p>
<p>一家之言 应试应试，无奈改变不了现状 八股八股，庆幸我走出了</p>
<h2 id="本我">本我</h2>
<p>人是喜欢的人和不喜欢的人的集合，是拿来主义的结果 那什么又是纯净的自己呢？ 是这一套拿来主义的原则吗？或许这套原则本身也是习得的，也不是原有的 弗洛伊德提出的三个概念，本我，自我，和超我 本我是指人格中最早，也是最原始的部分，是唯乐主义 那是否抛开了生理结构差异，智商差异，人人在一开始都一样了呢？ 在自我意识高度觉醒的现在，在这个追求个性的现在，这种观点看似不好被人接受 那究竟是什么？ 我欲抛砖引玉，却发现手中连块砖头都没有</p>
<hr>
<p>就这样吧，闲言碎语不想多讲，随性就好</p>
<p><strong>你住的城市下雨了，很想问你有没有带伞，可是我忍住了。因为我怕你说没带 而我又无能为力，就像是我爱你 却给不到你想要的陪伴。</strong> 宫崎骏说过这一句话 道出了多少苹果和香蕉的无奈 合适的才是最好的 愿爱无忧</p>
<p>苹果和香蕉：我爱你，我可以给你我的全部，可是我只有香蕉，可是你只要苹果</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/13/随记1.13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Gold.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiyuan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/13/随记1.13/" itemprop="url">随记1.13</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-13T16:46:22+08:00">
                2017-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/随感/" itemprop="url" rel="index">
                    <span itemprop="name">随感</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="section">1200</h2>
<p>终于在夜里来了一次广州，马路上果然大多是货车。 路上没什么人，飘着微微细雨。 这个点，几乎所有华丽的建筑的装饰灯光已经关闭。 偶尔见到穿着塑料袋的流浪汉对着垃圾桶撒尿；疲惫的环卫工人裹着厚厚的工作服坐在报亭旁睡着。 冷？冷清</p>
<p>先去了体育东的1200，狭小却挤满了读者，几个人没有座位索性坐在楼梯上就开始阅读；一位大叔在角落里架着摄像机，也许是在准备微博上的一天一人一个故事？温馨的钢琴曲，免费的柠檬水，再狭小也有一间沙发客的住所，一隅能够躲避屋外寒冷细雨的屋舍，一盏温暖的城市里的明灯。</p>
<p>传言这里不卖畅销书？然而我进去之后看到《谁的青春不迷茫》这种，满满失望，更失望的是，我本以为能够找到《写在人生边上》或者《走在人生边上》，我当然可以去亚马逊邮寄过来，然而我更抱着一丝深夜咖啡，暖灯下阅读一篇篇小品文的幻想，呵。</p>
<p>没有就撤吧，再去天河北，路上看到马路对面的西西弗书店，哦？万菱汇早就关门了。跟着百度地图走了大概45分钟，到达了这里，宽敞了许多，人少了许多。我进来直奔书架，两个品类映入眼帘，<strong>诗和远方</strong>，呵。</p>
<p>书架上，我看到了《洗澡》，看到了《我们仨》，看到了《围城》，希望一点一点燃起，然而最终还是没有看到我想阅读的那两本书。罢了，无缘无缘，店里响起《one of us》的吉他就想起方渐鸿来，呵。</p>
<h2 id="再见乌托邦">再见，乌托邦</h2>
<p>一个月前看了网易出的国摇30年的纪录片，看完说不出话来。 前两天看了纪录片《再见，乌托邦》，看完只能默默的抽烟。</p>
<p>张炬死了，剩下刘老五的唐朝，也难再听到《国际歌》了； 崔健因为一首戏谑的《南泥湾》被央视封杀20年； 同样是唱西藏，郑钧的《风马》和《回到拉萨》简直不能比； 窦唯现在拒绝一切公共场合的发言了，也许是古乐，也许是后摇了，虽然没有那么闪闪发亮，但也是一个艺术家； 黑豹，怎么说呢，就算我们不拿窦唯在的时候对比，现在同时代的音乐也就一般般了吧，新歌歌名《键盘·狭》，我快以为是网络歌曲了； 张楚，他说他还在做音乐吧，也许吧。 何勇…… 长江后浪推前浪，他们都已经不再是如今摇滚圈里当红的人物了，也许他们�活得不差，也许他们也在做自己喜欢的事情，没有必要为了我们的喜好再去怎样怎样。</p>
<p>然而，我看过最难受的是，吴柯的父母谈及自己儿子24就自杀的无奈与自责，抑或是茫然，他父亲还帮忙制作了《一无所有》，他们对摇滚，又是怎样的态度呢。</p>
<p>我看过最难受的是，94年红磡魔岩三杰里台风最牛逼的何勇，戴着红领巾在台上大喊姑娘漂亮的何勇，父亲为其伴奏三弦儿，窦唯为其吹笛子的何勇，发福了，疯了，精神出问题了。</p>
<p>吃饭那段，镜头里的他是那么不安，与这个现代化的社会是那么格格不入； 他说没钱，一年只能去小酒吧演出3场，能不能再去找魔岩要点钱，由头则是10年间他们超出了授权期一直在卖他的唱片。他说，他就想去个安静的地方，养条狗，看书弹琴，什么都不想，然而也没钱去实现，后来，后来住进精神病医院了吧。</p>
<p>当年台上叱咤风云，如今温饱也许都成问题。 除了转型不错的，你说历史残酷，你说产业剧变，唱片业衰落，电子音乐崛起；你说张楚何勇没跟得上时代的发展，那么那么国摇的未来呢？你去看草莓，你去看迷笛，现在不是没有好听的摇滚歌曲，不是没有躁动的摇滚现场，可是，哪个乐队能再唱出《垃圾场》？哪个乐队能再唱出《高级动物》？也许我接触的不够多，但是放眼望去，除了万青还在控诉着工业时代的矛盾，还在呐喊着理想主义，我再看不到别人。</p>
<p>对，摇滚，也许关系最为紧密的词语，就是理想主义。 我之前写过：摇滚是思想碰撞的产物，摇滚牛逼是因为产生了思想的共鸣，大家把摇滚乐手视为意见领袖，在社会制度和解放思想矛盾没有那么尖锐的今天，在大多数人已经小康的今天，或是教育水平越来越发达的今天，拿起鼓棒，敲给谁听呢？</p>
<p>如果将来的将来，我不相信每个阶段社会都会平稳过渡；矛盾总会有，如果我们都学会以更理性的，更温和的方式去看待，去接受，去改进了；没有人呐喊，没有人激起愤青骨子里的热血，甚至没有愤青了，那说明，社会主义精神文明建设见到成效了，我们都变成文明人了。</p>
<p>第一个纪录片《少年心气》中，大家一致看好商业化的完善会让中国的摇滚走向更好的未来，是有一个更公平的竞争平台，好听的音乐能够脱颖而出；然而，理想主义的缺失，再好听的歌曲，没有了从思想上打动人的地方，商业化也能解决吗？</p>
<h2 id="痛仰">痛仰</h2>
<p>痛苦的信仰变成了痛仰； 自刎哪吒变成了闭目哪吒； 《哪里有压迫，哪里就有反抗》变成了《愿爱无忧》；</p>
<p>虎哥的歌儿没有变得不好听，相比早期的嘶吼； 我反而更喜欢《两个人的假期》和《带着镣铐起舞》</p>
<p>痛仰，是让我对意见领袖这个词语思考最多的一个乐队。 直到前一段田然出事儿，虎哥在微博上发的言论，依然让我觉得他像一个小孩儿一样耍赖皮。</p>
<p>之所以对虎哥印象深刻；他发的状态，言论涉及的话题；我觉得像极了有一段时间的我，处处叛逆，觉得个人自由大于一切，觉得一些教育就是洗脑；然而一样，从另一个角度考虑，制度的制订是为了群体利益的最大化，过分强调个人只会显得不成熟。至于洗脑，哈哈，见仁见智吧。你怎么能说接受的教育是洗脑，而接受与此相反的一些观点就不是呢？能够独立思考的人不会被洗脑，真正被洗脑的人唤不醒，何苦何苦。</p>
<p>不喜欢的一点就是，网易云下，虎哥发动态，下面人开始撕，然后虎哥开始骂，到最后偏了题，开始互喷，最后演变成了：</p>
<p>你就是傻逼 我就是这样，不喜欢的滚。 …</p>
<p>还是爱呀，毕竟 社会需要愤青， 社会需要有人从另一方面激发人们的思考， 社会需要有人提醒人们不要轻信一切。</p>
<h2 id="自我意识">自我意识</h2>
<p>存钱干嘛，最应该舍得的就是要投资自己； 来一次说走就走的旅行； 男人（女人）就要对自己好一点； 不能说错，然而类似的观点多得让我觉得我们被这种观念洗了脑。</p>
<p>每个人都应该努力奋斗，买车买房； 中国人在做American Dream？ 要知道08年的经济危机的诱因之一就是过于乐观的美国梦，有了这个支持，大家才会觉得房价永不会跌，那些信用评级机构才敢放心大胆的去将一些金融衍生品以次充好，导致最后巨大的杠杆崩盘的。</p>
<p>如何应对不时之需呢？ 如何考虑孝敬父母呢？ 如何做一个长期的可持续的规划呢？</p>
<p>这一点我只是有感性的触动，目前没有怎样深入的思考。</p>
<p>##生活不止眼前的苟且，还有远方的苟且 生活不止眼前的苟且，过完了眼前的苟且，远方依然是苟且； 因为，至少像我这样的人，有生之年是见不到自己填平欲望的沟壑了； 诗和远方，也许只存在于幻想中吧。</p>
<h2 id="变节">变节</h2>
<p>GayScript，现在直接叫徐沪生了，江苏高考200分的数学卷子（不知道他考多少，但是高中做江苏卷的经历告诉我江苏那边的人，数学个顶个的变态），信息学竞赛保送到上交读软工，多好一个程序员，后来弃坑写文学作品去了…</p>
<p>我当时还不屑呢，现在发现自己写软文也快感十足，欲罢不能…变节变节</p>
<hr>
<p><strong>观点仅代表此刻想法，不成熟之处，还望指教</strong></p>
<p>完成，没读到书，那就走吧，继续逛~ 一杯死贵的咖啡。。。不过看环境这么好就原谅了吧。 写完，我自己都有点不肯定自己的观点，偏激和片面，然而我更希望的是有人可以交流。 我一直信奉一句话：</p>
<p><strong>思想因碰撞而深刻</strong></p>
<p>我的无脑叛逆就是跟我爸一次次辩论中扭过来的。而且这些碰撞之后形成的观点让我更能有体会。</p>
<p>That’s all.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/修行/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Gold.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiyuan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/修行/" itemprop="url">修行</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T16:46:22+08:00">
                2017-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/随感/" itemprop="url" rel="index">
                    <span itemprop="name">随感</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>不知道为什么，我喜欢的一个简书的作者停更了。所以每次打开简书些许也有些寂寞。</p>
<p>这是跨年夜，也或许是个巧合，其实看着朋友圈里一个个在抒发情感，去年的新年愿望实现了吗，去年收获了什么，今年又要继续加油…..也颇有感慨。</p>
<p>我只是要毕业了。</p>
<p>今天长隆，草莓跨年，买了通票，今天却没去成，错过了万青，错过了新裤子，错过了痛仰，几乎是我对这次草莓的全部期待了。</p>
<p>9个小时之前，补考5000米，我这周临时抱佛脚，中间练了一次跑进了23分，觉得稳了，然而结果还是23分41秒。</p>
<p>一周之前，期末考核，5000米，23分30过，我23分42；成为了当天我们年级第一个没过的人；朋友说，要是你再努力一点呢，说不定就过了，结果那次的结果导致了补考，又不知为什么补考从周五推迟到了今天；导致了今天去不了草莓。</p>
<p>一年半之前，大二结束，按照中大的政策，大三的成绩不计入保研评测，我随意玩，随意选，想学什么学什么，玩游戏想通宵就通宵，睡过头，课想翘就翘，期末复习也没什么动力，于是我收获了大学的第一个60分，大三一年绩点渣到爆；gfs这边政策一变，我的保研就变成了飘忽不定的事情。</p>
<p>晚上回来，我恨恨的说，要是我就24分多，我现在屁都不放一个，那就是没练，怎么着都不行，偏偏就这十几秒，而且我自己练还能过，我要是中间知道，再逼自己紧一点，说不定就过了。</p>
<p>今天考核，一个哥们儿跑休克了，我们去医院看他，回来的路上聊到另一个哥们儿，也是考核的时候，跑完整个人虚脱，我说，我啥时候有些决心把自己逼到这份儿上，能快多少呢。</p>
<p>亦或是说，虽然保研这件事情对我来说可能目前是最好的结果，但是如果我大三没那么放纵，也不会卡在这个位置这么尴尬。我就是活的太安逸了，我不想说，优秀的人都是最努力的，这就是屁话，我只是想看看竭尽全力的我到底是个什么样子。</p>
<p>因为我心里还是太难受了。人啊，找准自己的位置很重要，但是我真正审视一下自己，我追求的东西，出路，感情，太多太多都不是属于我的世界的东西。那我能怎么办，接受自己永远得不到的事实？还是抱有幻想的再去拼一把，再去接受？</p>
<p>5000多简单，就那二十几分钟，到了终点线，过了就是过了，没过就是没过。然而生活中好多事情根本不存在终点，我又怎样知道什么时候该停止脚步，把现状当成结果呢？</p>
<p>生存就已经很艰难，再去追求一些不属于自己的世界的人和事，谁知道又要付出多少的艰辛呢？美好的事物人人都喜欢，然而若不是天资聪颖，卓尔不群，真正有勇气有毅力的人才有一定几率得到。同样，信仰因为付出的努力而变得高贵。</p>
<p>室友说，人活着就是遭罪。我以前觉得纨绔子弟很帅，老子什么都不在乎，把一切都不放在眼里，多快活，甚至别人说不定还羡慕我。也许，我现在过了那个年龄吧，也许只是吃了太多亏了，不再觉得那是我想要的。我说，5000没过，心里总是个事儿呀，不敢放开了吃，不敢不练了，可是回过头一想，本来就应该这样呀，谁说除了考核前那几周控制饮食，其他时间就要大吃大喝呢？谁说除了考试的复习周，其他时间都要昏天黑地呢？唉，这样活着什么乐趣呢，活着真累。是呀，活着就是遭罪，人生本来就是一次修行呀。</p>
<p>偶然跟同学交流，她说到我的想法很悲观。我也承认，最近失意的事情确实太多，修行的结果，或是说人生的意义，哦，那就又要回到上一篇文章了。</p>
<p>总之，这一年挺失败的，从头到尾，挺失败的，然而这一年过去了，没获得什么，就是离这次艰难的修行的终点又近了一步。如果说，我也陈词滥调，要给2017年的自己一个忠告，哦，那请对自己狠一点，再狠一点。</p>
<p>瞎写，仅代表此时此刻的观点，That’s all.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/15/Scrapy爬取大众点评/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Gold.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiyuan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/15/Scrapy爬取大众点评/" itemprop="url">Scrapy爬取大众点评</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-15T16:46:22+08:00">
                2016-12-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Mining/" itemprop="url" rel="index">
                    <span itemprop="name">Data Mining</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="内容">内容：</h2>
<p>美食品类750个商家：</p>
<blockquote>
<ul>
<li>商家的页面url</li>
<li>商家的主要信息</li>
<li>商家所有的促销信息（1200+条）</li>
<li>商家所有的评论信息（没爬完，14w+条）</li>
<li>发表这些评论的所有用户的信息（没爬完，5w+条）</li>
</ul>
</blockquote>
<p>代码：https://github.com/preke/Spiders/tree/master/DaZhongDianPing</p>
<h2 id="总结和学习的一些点">总结和学习的一些点：</h2>
<ol type="1">
<li><p>大众点评有反爬机制，直接运行爬虫，会返回403 forbidden, 所以要换UA, 这里我参考了这篇文章 http://blog.csdn.net/haipengdai/article/details/48545231 （亲测这个中间件太厉害了，同学遇到的输入验证码的问题我都没遇到）</p></li>
<li><p>scrapy高度集成，设置完 <code>start_urls</code> 之后, <code>start_request()</code> 根据 <code>start_urls</code> 的url生成 <code>Request</code> 对象,然后访问网页返回一个<strong>可迭代</strong>的 <code>Response</code>对象，直接默认回调<code>parse()</code>；<code>parse()</code>返回的<strong>可迭代</strong>的<code>Request</code>对象，直接默认回调<code>start_request()</code>。</p></li>
</ol>
<p><strong>注: 这里的Request对象和Response对象是scarpy里定义的：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Request</span><br><span class="line"><span class="keyword">from</span> scrapy.http <span class="keyword">import</span> Response</span><br></pre></td></tr></table></figure>
<p>具体说明：http://scrapy-chs.readthedocs.io/zh_CN/stable/topics/request-response.html#module-scrapy.http 而具体这个可迭代，因为内部实现时用迭代器，所以返回的时候，可以在返回对象上加一个’[]’</p>
<ol start="3" type="1">
<li>多个爬虫pipline的问题，这样解决：</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> spider.name == <span class="string">'url'</span>:</span><br><span class="line">        do url things...</span><br><span class="line">    <span class="keyword">elif</span> spider.name == <span class="string">'shop'</span>:</span><br><span class="line">        sdo url things...</span><br><span class="line">    <span class="keyword">elif</span> spider.name == <span class="string">'promotion'</span>:</span><br><span class="line">        do url things...</span><br><span class="line">    <span class="keyword">elif</span> spider.name == <span class="string">'comment'</span>:</span><br><span class="line">        str1 = type(item)</span><br><span class="line">        <span class="keyword">if</span> str(str1) == <span class="string">"&lt;class 'Xiuxian.items.CommentItem'&gt;"</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">'ok'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.saveOrUpdate(self.user_collection, item)</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><p>遇到ajax要自己定义请求发送，然后遇到302，原因还是ua的问题，我通过<code>requests</code>库的<code>request</code>直接发get请求，发现返回的时重定向的页面，然后把请求委托给scrapy封装的<code>Request</code>,就可以获取信息（因为会通过中间件来换UA）。 推荐使用<code>postman</code>先试一下，如果请求需要参数中有时间戳，可以自己随便设（仅限于本例，其他的还不清楚）</p></li>
<li><p>后来遇到最大的问题是应对大众点评的反爬机制，中间折腾了各种各样的方法，不再累述，只说问题的结论：</p></li>
</ol>
<blockquote>
<ul>
<li>我也遇到了输入验证码和403两个问题</li>
<li><code>crawlera</code>开始收费了</li>
<li>西次网的代理ip不靠谱，或者说是首页的ip不靠谱</li>
<li>自己用vmware开了6个虚拟机桥接网络，然后装上<code>polipo</code>做代理</li>
<li>自己写代理中间件，从代理池中<code>random.choice()</code>的效果不如我写一个时间片轮转的效果好，而且桥接网络的代理ip质量好像也不太高，有些也会被临时禁用。（本质感觉还是代理质量不高）</li>
<li>最后用几个可用的ip代理做轮转，一个连续发3个请求，然后换另一个，<code>DOWNLOAD_DELAY</code> 设为0.25</li>
</ul>
</blockquote>
<h2 id="总结">总结：</h2>
<ul>
<li>自己写的程序质量不高，发送请求的地方应该可以继续优化；</li>
<li>有高质量的代理肯定是好事，会省很多工作，或许说是偷懒的一种方式</li>
<li>师兄说了一个点，弄清楚程序发送请求和浏览器发送请求的区别，这是努力的一个点</li>
<li>引发了一个思考，可能是懂的太少：既然可以用代理池，分布式爬虫的意义在哪里？</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/10/aim_to_offer_25/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Gold.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiyuan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/10/aim_to_offer_25/" itemprop="url">剑指offer 面试题25 二叉树中和为某一值的路径</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-09-10T16:46:22+08:00">
                2016-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试题/" itemprop="url" rel="index">
                    <span itemprop="name">面试题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。二叉树结点的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  BinaryTreeNode* left;</span><br><span class="line">  BinaryTreeNode* right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="想法">想法：</h2>
<p>先理解路径，就是树根到叶子节点的条路，那我们先实现出打印出路径的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    v.push_back(root-&gt;value);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; <span class="comment">//到叶子结点</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i ++) &#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      </span><br><span class="line">      v.pop_back();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) </span><br><span class="line">      FindPath(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">      FindPath(root-&gt;right);</span><br><span class="line">    v.pop_back(); <span class="comment">//访问过该节点，就pop掉</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再想办法加入一个current变量记录当前的和，主要是为了剪枝： 如果中途（还没有到叶子节点）我们的current就已经比目标值sum大（或者相等）的话，就不必去访问该节点的叶子节点了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(BinaryTreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    v.push_back(root-&gt;value);</span><br><span class="line">    current += root-&gt;value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;  <span class="comment">//到叶子结点</span></span><br><span class="line">      <span class="keyword">if</span> (current == sum) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i ++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      current -= root-&gt;value;</span><br><span class="line">      v.pop_back();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (current &gt;= sum) &#123;</span><br><span class="line">      current -= root-&gt;value;</span><br><span class="line">      v.pop_back();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) </span><br><span class="line">      FindPath(root-&gt;left, sum);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">      FindPath(root-&gt;right, sum);</span><br><span class="line"></span><br><span class="line">    current -= root-&gt;value;</span><br><span class="line">    v.pop_back(); <span class="comment">//访问过该节点，就pop掉</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/31/进程同步/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Gold.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiyuan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/31/进程同步/" itemprop="url">进程同步</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-31T16:46:22+08:00">
                2016-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/理解计算机/" itemprop="url" rel="index">
                    <span itemprop="name">理解计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p>
<h2 id="临界资源">临界资源</h2>
<p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所使用，我们把一次仅允许一个进程使用的资源称为临界资源。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p>
<p>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用，可以把临界资源的访问过程分成四个部分：</p>
<ul>
<li>进入区。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，如果可以进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li>
<li>临界区。进程中访问临界资源的那段代码，又称临界段。</li>
<li>退出区。将正在访问临界区的标志清除。</li>
<li>剩余区。代码中的其余部分。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    entry section;  <span class="comment">//进入区</span></span><br><span class="line">    critical section;  <span class="comment">//临界区</span></span><br><span class="line">    <span class="built_in">exit</span> section;  <span class="comment">//退出区</span></span><br><span class="line">    remainder section;  <span class="comment">//剩余区</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>
<h2 id="同步">同步</h2>
<p>同步亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p>
<p>例如，输入进程A通过单缓冲向进程B提供数据。当该缓冲区空时，进程B不能获得所需数据而阻塞，一旦进程A将数据送入缓冲区，进程B被唤醒。反之，当缓冲区满时，进程A被阻塞，仅当进程B取走缓冲数据时，才唤醒进程A。</p>
<h2 id="互斥">互斥</h2>
<p>互斥亦称<strong>间接制约关系</strong>。当一个进程进入临界区使用临界资源时，另一个进程必须等待, 当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p>
<p>例如，在仅有一台打印机的系统中，有两个进程A和进程B，如果进程A需要打印时, 系统已将打印机分配给进程B,则进程A必须阻塞。一旦进程B将打印机释放，系统便将进程A唤醒，并将其由阻塞状态变为就绪状态。</p>
<p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：</p>
<ul>
<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li>
<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li>
<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区。</li>
<li>让权等待。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li>
</ul>
<p>进一步阐释： http://blog.csdn.net/theone10211024/article/details/14052035</p>
<h1 id="实现临界区互斥的基本方法">实现临界区互斥的基本方法</h1>
<h2 id="算法一单标志法">算法一：单标志法。</h2>
<p>该算法设置一个公用整型变量turn,用于指示被允许进入临界区的进程编号，即若turn=0，则允许P0进程进入临界区。该算法可确保每次只允许一个进程进入临界区。但两个进程必须交替进入临界区，如果某个进程不再进入临界区了，那么另一个进程想再次进入临界区，则它将无法进入临界区（违背“空闲让进”）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// P0进程</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">0</span>);</span><br><span class="line">critical section;</span><br><span class="line">turn=<span class="number">1</span>;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// P1进程</span></span><br><span class="line"><span class="keyword">while</span>(turn!=<span class="number">1</span>);  <span class="comment">// 进入区</span></span><br><span class="line">critical section;  <span class="comment">// 临界区</span></span><br><span class="line">turn = <span class="number">0</span>;  <span class="comment">// 退出区</span></span><br><span class="line">remainder section;  <span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>
<h2 id="算法二双标志法先检查">算法二：双标志法先检查。</h2>
<p>该算法的基本思想是在每一个进程访问临界区资源之前，先查看一下临界资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。为此，设置了一个数据flag[i]，如第i个元素值为FALSE，表示Pi进程未进入临界区，值为TRUE，表示Pi进程进入临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pi 进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[j]);  <span class="comment">// ①    </span></span><br><span class="line">flag[i]=TRUE;  <span class="comment">// ③  </span></span><br><span class="line">critical section;   </span><br><span class="line">flag[i] = FALSE; </span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pj 进程</span></span><br><span class="line"><span class="keyword">while</span>(flag[i]);  <span class="comment">// ② 进入区</span></span><br><span class="line">flag[j] =TRUE;  <span class="comment">// ④ 进入区</span></span><br><span class="line">critical section;  <span class="comment">// 临界区</span></span><br><span class="line">flag[j] = FALSE;  <span class="comment">// 退出区</span></span><br><span class="line">remainder section;  <span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>
<p>优点：不用交替进入，可连续使用；缺点：Pi和Pj可能同时进入临界区。按序列①②③④ 执行时，会同时进入临界区（违背“忙则等待”)。即在检查对方flag之后和切换自己flag 之前有一段时间，结果都检查通过。这里的问题出在检查和修改操作不能一次进行。</p>
<h2 id="算法三双标志法后检查">算法三：双标志法后检查。</h2>
<p>算法二是先检测对方进程状态标志后，再置自己标志，由于在检测和放置中可插入另一个进程到达时的检测操作，会造成两个进程在分别检测后，同时进入临界区。为此，算法三釆用先设置自己标志为TRUE后,再检测对方状态标志，若对方标志为TURE，则进程等待；否则进入临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pi进程</span></span><br><span class="line">flag[i] =TRUE;</span><br><span class="line"><span class="keyword">while</span>(flag[j]);</span><br><span class="line">critical section;</span><br><span class="line">flag[i] =FLASE;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pj进程</span></span><br><span class="line">flag[j] =TRUE;  <span class="comment">// 进入区</span></span><br><span class="line"><span class="keyword">while</span>(flag[i]);  <span class="comment">// 进入区</span></span><br><span class="line">critical section;  <span class="comment">// 临界区</span></span><br><span class="line">flag [j] =FLASE;   <span class="comment">// 退出区</span></span><br><span class="line">remainder section;  <span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>
<p>当两个进程几乎同时都想进入临界区时，它们分别将自己的标志值flag设置为TRUE，并且同时检测对方的状态（执行while语句），发现对方也要进入临界区，于是双方互相谦让，结果谁也进不了临界区，从而导致“饥饿”现象。</p>
<h2 id="算法四petersons-algorithm">算法四：Peterson’s Algorithm。</h2>
<p>为了防止两个进程为进入临界区而无限期等待，又设置变量turn，指示不允许进入临界区的进程编号，每个进程在先设置自己标志后再设置turn 标志，不允许另一个进程进入。这时，再同时检测另一个进程状态标志和不允许进入标志，这样可以保证当两个进程同时要求进入临界区，只允许一个进程进入临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pi进程</span></span><br><span class="line">flag[i]=TURE; turn=j;</span><br><span class="line"><span class="keyword">while</span>(flag[j]&amp;&amp;turn==j); </span><br><span class="line">critical section;</span><br><span class="line">flag[i]=FLASE;</span><br><span class="line">remainder section;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pj进程</span></span><br><span class="line">flag[j] =TRUE;turn=i;  <span class="comment">// 进入区</span></span><br><span class="line"><span class="keyword">while</span>(flag[i]&amp;&amp;turn==i);   <span class="comment">// 进入区</span></span><br><span class="line">critical section;  <span class="comment">// 临界区</span></span><br><span class="line">flag[j]=FLASE;  <span class="comment">// 退出区</span></span><br><span class="line">remainder section;  <span class="comment">// 剩余区</span></span><br></pre></td></tr></table></figure>
<p>本算法的基本思想是算法一和算法三的结合。利用flag解决临界资源的互斥访问，而利用turn解决“饥饿”现象。</p>
<h2 id="reference">Reference:</h2>
<p>http://c.biancheng.net/cpp/html/2596.html http://c.biancheng.net/cpp/html/2597.html</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/30/【Unix网络编程读书笔记】第四章 基本TCP套接字编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Gold.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiyuan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/30/【Unix网络编程读书笔记】第四章 基本TCP套接字编程/" itemprop="url">【Unix网络编程读书笔记】第四章 基本TCP套接字编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-30T16:46:22+08:00">
                2016-08-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/UNP读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">UNP读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="socket函数">socket函数</h2>
<p>指定期望的通信协议类型 socket()创建套接字，指定期望的通信协议类型；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> family, <span class="keyword">int</span> type, <span class="keyword">int</span> protocal)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数：</li>
</ul>
<p>family指明协议族（协议域） type指明套接字类型 protocal某个协议类型常值，或者设为0</p>
<ul>
<li>返回值： 非负描述符（sockfd） – 成功，-1 – 出错</li>
</ul>
<p>单纯调用socket函数：</p>
<ul>
<li>指定了协议族和套接字类型</li>
<li>没有指定本地协议地址或远程协议地址</li>
</ul>
<h2 id="connect函数">connect函数</h2>
<p>TCP客户用于建立与TCP服务器的连接,可以理解为发送SYN</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* servaddr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>参数: sockfd: socket函数返回的一个套接字描述符 servaddr: 一个指向套接字地址结构的指针(该结构包括IP地址和端口号) addrlen: 该结构的大小</p></li>
<li><p>返回值： 若无错误发生，则connect()返回0。 否则的话，返回SOCKET_ERROR错误</p></li>
</ul>
<h3 id="客户在调用connect函数之前不必非得调用bind函数需要的话内核会确定源ip地址并选择一个临时端口作为源端口">客户在调用connect函数之前不必非得调用bind函数，需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。</h3>
<p>错误返回：</p>
<ul>
<li>若TCP客户没有收到SYN分节的相应，则返回ETIMEDOUT错误</li>
<li>若客户收到RST,表明服务器上没有进程等待与之连接（如服务器进程没在运行）。这是一种<strong>硬错误（hard error）</strong>,用户已接受到RST就马上返回ECONNERFUSED错误</li>
<li>若客户发出的SYN在中间的某个路由器上引发了一个“destination unreachable”的ICMP错误，则认为是一种<strong>软错误（soft error）</strong>。客户按照时间间隔继续发SYN，如果在规定时间内还没有得到响应，则返回EHOSTUNREACH或ENETUNREACH给客户端进程。 引发该错误的两种原因，1是按照本地转发表到不了服务器的路径，2是connect调用根本不等待就返回。</li>
</ul>
<p>如果connect失败，则要close当前的sockfd，并且重新调用socket函数创建新的套接字</p>
<h2 id="bind函数">bind函数</h2>
<p>bind函数将一个本地协议地址赋予一个套接字。 协议地址： 32位的IPv4地址或128位的IPv6地址 + 16位TCP/UDP端口号</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* myaddr, <span class="keyword">socklen_t</span> addrlen)</span></span></span><br></pre></td></tr></table></figure>
<p>参数表和connect很像，同一个sockfd，先bind本机地址，再connect对端地址 后两个参数，可以指定一个，也可以不指定，如上述：客户在调用connect函数之前不必非得调用bind函数，需要的话，内核会确定源IP地址，并选择一个临时端口作为源端口。</p>
<p>客户机：IP地址为源IP地址 服务器：IP地址意味着服务器只接受那些目的地为这个IP地址的客户机连接</p>
<p>客户机通常不绑定IP地址到套接字，而是建立连接时，内核将根据所用的外出网络接口来选择源IP地址。 如果服务器没有绑定IP地址，则选用收到的客户机的SYN请求的目的地作为服务器的源IP地址</p>
<p>如果两者都不指定，则设置IP地址为通配地址，端口号为0</p>
<p>如果想要知道内核选择的临时的端口值，必须调用getsockname</p>
<p>返回值：成功为0，不成功为-1</p>
<p>bind常见的返回错误为EADDRINUSE(Address already in use)地址已使用</p>
<h2 id="listen函数">listen函数</h2>
<p>仅由TCP服务器调用，做两件事情：</p>
<ol type="1">
<li>listen函数将一个未连接的主动套接字转换为被动套接字（监听套接字），将CLOSE状态转换到LISTEN状态。</li>
<li>第二个参数规定了内核应该为相应套接字排队(见下)的最大连接个数</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值： 若成功返回0，若出错则为-1</p>
<p>内核为任何一个监听套接字维护两个队列（队列里存的是SYN分节）</p>
<ul>
<li><p>未完成连接队列（incomplete connection queue） 每个这样的SYN分节处于TCP三次握手过程中，处于SYN_RCVD状态</p></li>
<li><p>已完成连接队列（completed connection queue） 已经完成TCP三次握手，处于ESTABLISHED状态</p></li>
</ul>
<p>一般来说，两个队列之和不超过backlog</p>
<p>如果未完成序列满了之后，TCP客户端发送一个SYN分节，服务端不响应，也不发送RST，让TCP期望下一次重传，有可能未完成序列会有位置</p>
<p>在此理解SYN洪泛攻击就比较清楚了。预防的一种方法是，我们将backlog指定为某个给定套接字上内核为之排队的最大已完成连接数。这样就不必为了提供SYN洪泛的防护而设定一个很大的backlog值。</p>
<h2 id="accept函数">accept函数</h2>
<p>由TCP服务器调用，用于从已完成连接队列队头返回一个已完成连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* cliaddr, <span class="keyword">socklen_t</span>* addrlen)</span></span></span><br></pre></td></tr></table></figure>
<p>第一个参数为监听套接字描述符 后两个参数都是（返回参数，就是我们传入后两个参数，后两个参数会将我们传入的信息（包含客户机地址信息的一个地质结构）记录在一个本地的地址结构里）客户端的信息，标识客户端的协议类型，IP地址，端口号。 （若对客户端信息不感兴趣，可以置空，也就是不记录） 为什么可以置空呢？如果我们在并发服务器上，有多个进程在accept，那如果不保留客户端信息，我们怎么知道该回给哪一个呢？ 我暂时先瞎理解：accept函数是处理的客户端的SYN请求（从已完成连接队列中取出一个SYN分节），那么该分节里本身包含了客户端的源IP地址和端口号，所以即使置空，我们解析包的时候也能够提取到客户端的信息</p>
<p>若成功返回非负描述符（已连接套接字描述符），不成功返回-1。</p>
<p>一个服务器（个人觉得是对于一个服务，不保证一个服务器上不同的IP地址和端口号可以处理不同的服务）通常只有一个&lt;font color=“red”-*监听套接字**，然后内核为每个由服务器进程接受的客户创建(通过accept函数)一个&lt;font color=“red”-*已连接套接字**， 当服务完成的时候，相应的已连接套接字关闭。</p>
<h2 id="fork和exec函数">fork和exec函数</h2>
<h3 id="fork函数">fork函数：</h3>
<p>是Unix中派生新进程的唯一方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>返回值： 在子进程中为0 在父进程中为子进程ID 出错为-1</p>
<p>父进程调用accept之后调用fork，accept创建的已连接套接字与fork出的子进程共享，之后，子进程继续读写这个已连接套接字，父进程关闭这个已连接套接字。</p>
<p>fork两个典型用法： 1. 一个进程创建自身的副本，然后两个进程并发执行 2. 一个进程想要执行另一个程序。先fork出自身的一个副本，然后副本调用exec函数，把自身替换成新的程序。</p>
<h3 id="exec函数">exec函数</h3>
<p>有6个exec函数，统称为exec函数。 放在硬盘上的可执行文件被Unix执行的唯一方法是：由一个现有进程调用6个exec函数中的某一个，把当前的进程映像替换成新的程序文件，而且新程序同main函数开始执行，进程ID不改变。 调用exec的进程叫做 <strong>调用进程</strong> 新执行的程序为 <strong>新程序</strong></p>
<h2 id="并发服务器">并发服务器</h2>
<p>我觉得这段用书上的代码解释应该非常清楚： 都用了包裹函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Listen(listenfd, backlog);</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  connfd = Accept(listenfd, ...); </span><br><span class="line">  <span class="keyword">if</span> ( (pid = Fork()) == <span class="number">0</span> ) &#123; <span class="comment">//成功创建子进程</span></span><br><span class="line">    Close(listenfd); <span class="comment">//子进程关闭监听套接字, 父进程可以继续监听</span></span><br><span class="line">    doit(connfd); <span class="comment">//子进程在已连接套接字上读写</span></span><br><span class="line">    Close(connfd); <span class="comment">//完成与客户机的交互，断开连接</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//正常退出</span></span><br><span class="line">  &#125;</span><br><span class="line">  Close(connfd); <span class="comment">//父进程关闭已连接套接字</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>但是我觉得如果做到并发的话，第6~9行和第11行应该同时执行。</p>
<h2 id="close函数">close函数</h2>
<p>Unix中close函数也用来关闭套接字，断开TCP连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值： 成功为0 出错为-1</p>
<p>close将一个套接字标记为关闭，然后返回调用进程； 被标记为关闭的套接字不能再由调用进程使用，也就是不能再作为read和write的第一个参数。</p>
<h3 id="描述符引用计数">描述符引用计数</h3>
<p>通俗理解的话：并发中，fork会让对应的套接字引用计数加1，close函数会让对应的套接字引用计数减1，该计数被父进程和子进程共享（可读写），只有当该计数为0时，才会终止TCP连接，4次挥手。</p>
<h2 id="getsockname和getpeername函数">getsockname和getpeername函数</h2>
<p>getsockname返回某个套接字的本机协议地址 getpeername返回某个套接字所关联的外地协议地址 返回在这里，是返回参数的意思，即将信息填充到参数指向的结构中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* localaddr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* peeraddr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<p>返回值： 均为若成功：返回0 若失败：返回-1</p>
<p>用途：</p>
<ul>
<li>没有显式bind时，connect成功后，getsockname用于返回内核赋予该连接的IP地址和端口号；</li>
<li>bind时端口号参数为0时，connect成功后，getsockname用于返回内核赋予该连接的本地端口号；</li>
<li>getsockname用于获取套接字地址的地址族</li>
<li>服务器采用通配地址bind时，对已连接套接字调用getsockname也可以得到IP地址和端口号</li>
<li>服务器通过调用accept的进程通过exec执行程序时，获取客户身份的唯一途径是getpeername。</li>
<li>Telnet服务器首先调用的函数之一就是getpeername</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/28/aim_to_offer_06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Gold.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiyuan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/28/aim_to_offer_06/" itemprop="url">剑指offer 面试题6 重建二叉树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-28T16:46:22+08:00">
                2016-08-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试题/" itemprop="url" rel="index">
                    <span itemprop="name">面试题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>题目就是输入前序和中序来实现二叉树的重建，虽然感觉自己人为操作思路很清晰，但是写到程序里会觉得很繁琐，以前实现过，但是如果是面试的话，还是要熟练才好，真正理解每一句代码的思路。所以也算是克服恐惧来仔细分析一次吧。</p>
<p>（我没有用书上的代码来分析，而是用之前自己参照网上的版本写的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  BinaryTreeNode* pLeft;</span><br><span class="line">  BinaryTreeNode* pRight;</span><br><span class="line">&#125;BinaryTreeNode;</span><br></pre></td></tr></table></figure>
<p>结构体如上；</p>
<p>之前的实现（也是参照网上流传很广的版本）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">buildByPreAndIn</span><span class="params">(<span class="keyword">int</span>* pre_order, <span class="keyword">int</span>* in_order, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre_order == <span class="literal">NULL</span> || in_order == <span class="literal">NULL</span> || num &lt;= <span class="number">0</span>)  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    BinaryTreeNode* root = <span class="keyword">new</span> BinaryTreeNode;</span><br><span class="line">    root-&gt;value = *pre_order;</span><br><span class="line">    root-&gt;pLeft = root-&gt;pRight = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rootPositionInOrder = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in_order[i] == root-&gt;value) &#123;</span><br><span class="line">            rootPositionInOrder = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num_Left  = rootPositionInOrder;</span><br><span class="line">    <span class="keyword">int</span> num_Right = num - num_Left - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pre_order_left  = pre_order + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* in_order_left   = in_order;</span><br><span class="line">    root-&gt;pLeft          = buildByPreAndIn(pre_order_left, in_order_left, num_Left);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* pre_order_right = pre_order + num_Left + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>* in_order_right  = in_order + num_Left + <span class="number">1</span>;</span><br><span class="line">    root-&gt;pRight         = buildByPreAndIn(pre_order_right, in_order_right, num_Right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好的我们先看函数头：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode* <span class="title">buildByPreAndIn</span><span class="params">(<span class="keyword">int</span>* pre_order, <span class="keyword">int</span>* in_order, <span class="keyword">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure>
<p>前两个参数就是前序和中序数组的首地址，那么num呢？就是数组的长度（两个一样长）。</p>
<p>然后是终止条件，也很清晰；</p>
<p>接着用前序数组的第一个元素，创建一个节点，既是根节点，又是之后每次递归的时候创建的新节点。</p>
<p>然后去找中序数组中，前序数组第一个节点的位置，以此来区分左右子树。</p>
<p>然后用两个变量： <code>num_Left</code>记录左子树节点的个数； <code>num_Right</code>记录右子树节点的个数；</p>
<p>知道了长度，还要知道前序中序两个数组的首地址吧，然后再用两个变量： <code>pre_order_left</code>记录左子树前序子数组的起始位置； <code>in_order_left</code>记录左子树中序子数组的起始位置； 两个长度相等，所以递归调用函数创建左子树。</p>
<p>右子树是相同的过程，重要的是找起始位置的时候要空出根节点。</p>
<p>然后返回创建的树的根节点。</p>
<p>这样一分析，就觉得思路更加明晰了，我觉得就算是面试，也是要记下这个思路吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/24/aim_to_offer_01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhiyuan">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/Gold.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zhiyuan">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/24/aim_to_offer_01/" itemprop="url">剑指offer 面试题1 赋值运算符函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-08-24T16:46:22+08:00">
                2016-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试题/" itemprop="url" rel="index">
                    <span itemprop="name">面试题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>题目要求为下面一个类实现一个赋值运算符的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">NULL</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~CMyString();</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们要实现任意的一个类的赋值运算符函数，都要注意一些方面：</p>
<ul>
<li>返回值类型是类引用，返回*this</li>
<li>参数类型是常量引用</li>
<li>如果有动态内存，是否发生内存泄露</li>
<li>如果传入参数为调用者自身，直接返回</li>
</ul>
<p>书上的解法给的确实很完备，而且后来用了一种巧妙的方法让程序自动释放内存。但我觉得重点是他提到的异常安全性的处理，这里的话如果我们在new的时候内存不够，而我们又已经delete掉原来的内存，就会导致调用者的内存被无故释放了；所以书上采用新建临时变量，然后再让*this的m_pData指针和临时变量的m_pDatam做交换，就算如果新建临时变量的时候内存不够，也可以保证调用者调用失败也没有被改变。</p>
<p>但是我想了一下，异常安全性的思想是很宝贵，但是实现起来其实可以用try catch这样也很直观：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CMyString &amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString&amp; str) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str) &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> [] <span class="keyword">this</span>-&gt;m_pData;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_pData = <span class="keyword">new</span> <span class="keyword">char</span> [<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;m_pData, str.m_pData);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(<span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"申请内存错误，赋值失败，返回原对象"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里提到赋值运算符的话，就要顺便说一下拷贝构造函数；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CMyString s2;</span><br><span class="line">CMyString s1 = s2; <span class="comment">//这一行其实调用的是拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p>区别就在于，拷贝构造函数的调用，之前是没有对象的，所以如果有动态内存，拷贝构造函数肯定不会先去delete； 而赋值运算符是讲一个对象赋给另外一个对象，之前是有对象的，这么一来就有了对之前对象的处理。</p>
<p>我把所有函数的实现和一些注意事项放在这里啦~</p>
<p>https://github.com/preke/AimToOffer/blob/master/01.c%2B%2B</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/Gold.jpg" alt="Zhiyuan">
            
              <p class="site-author-name" itemprop="name">Zhiyuan</p>
              <p class="site-description motion-element" itemprop="description">三尺微命，一介书生</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/preke" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:geek00021@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.facebook.com/PrekeWen" target="_blank" title="FB Page">
                      
                        <i class="fa fa-fw fa-facebook"></i>FB Page</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/u013398398" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-home"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/85555f21e657" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-home"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://scholar.google.com.hk/citations?user=bLhErOwAAAAJ&hl=en" target="_blank" title="Google Scholar">
                      
                        <i class="fa fa-fw fa-graduation-cap"></i>Google Scholar</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://preke.github.io/cv/resume.html" target="_blank" title="Resume">
                      
                        <i class="fa fa-fw fa-user"></i>Resume</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhiyuan</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
















  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
